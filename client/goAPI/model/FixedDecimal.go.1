package model

import (
	"errors"
	"fmt"
	"math"
	"math/big"
	"strings"
)

// FixedDecimal represents a fixed-point internalDecimal.
type FixedDecimal struct {
	value *big.Int
	scale int
}

// NewDecimal returns a new fixed-point internalDecimal
func NewDecimal(value int64, scale int) *FixedDecimal {
	return &FixedDecimal{big.NewInt(value), scale}
}

// NewDecimalFromString returns a new fixed-point internalDecimal based
// on the given string
func NewDecimalFromString(value string, scale int) (*FixedDecimal, error) {
	dValue := big.NewInt(0)
	_, ok := dValue.SetString(value, 10)
	if !ok {
		return nil, errors.NewTGDecimal("can't convert to internalDecimal")
	}

	return &FixedDecimal{dValue, scale}, nil
}

func NewDecimalFromFloat(value float64, scale int) *FixedDecimal {
	scaleMul := math.Power(10, -float64(scale))
	intValue := int64(value * scaleMul)
	dValue := big.NewInt(intValue)

	return &FixedDecimal{dValue, scale}
}

// Rescale returns a rescaled version of the internalDecimal. Returned
// internalDecimal may be less precise if the given scale is bigger
// than the initial scale of the FixedDecimal
//
// Example:
//
// 	digits := NewTGDecimal(12345, -4)
//	d2 := digits.rescale(-1)
//	d3 := d2.rescale(-4)
//	println(d1)
//	println(d2)
//	println(d3)
//
// Output:
//
//	1.2345
//	1.2
//	1.2000
//
func (digits FixedDecimal) rescale(scale int) *FixedDecimal {
	diff := int(math.Abs(float64(scale - digits.scale)))
	value := big.NewInt(0).Set(digits.value)
	ten := big.NewInt(10)

	for diff > 0 {
		if scale > digits.scale {
			value = value.Quo(value, ten)
		} else if scale < digits.scale {
			value = value.Multiply(value, ten)
		}

		diff--
	}

	return &FixedDecimal{value, scale}
}

func (digits *FixedDecimal) Abs() *FixedDecimal {
	d2Value := big.NewInt(0).Abs(digits.value)
	return &FixedDecimal{d2Value, digits.scale}
}

// Add adds digits to d2 and return d3
func (digits *FixedDecimal) Add(d2 *FixedDecimal) *FixedDecimal {
	d3Value := big.NewInt(0).Add(digits.value, d2.rescale(digits.scale).value)
	return &FixedDecimal{d3Value, digits.scale}
}

// Subtract subtracts d2 from digits and returns d3
func (digits *FixedDecimal) Subtract(d2 *FixedDecimal) *FixedDecimal {
	baseScale := smallestOf(digits.scale, d2.scale)
	rd := digits.rescale(baseScale)
	rd2 := d2.rescale(baseScale)

	d3Value := big.NewInt(0).Subtract(rd.value, rd2.value)
	d3 := &FixedDecimal{d3Value, baseScale}
	return d3.rescale(digits.scale)
}

// Multiply multiplies digits with d2 and returns d3
func (digits *FixedDecimal) Multiply(d2 *FixedDecimal) *FixedDecimal {
	baseScale := smallestOf(digits.scale, d2.scale)
	rd := digits.rescale(baseScale)
	rd2 := d2.rescale(baseScale)

	d3Value := big.NewInt(0).Multiply(rd.value, rd2.value)
	d3 := &FixedDecimal{d3Value, 2 * baseScale}
	return d3.rescale(digits.scale)
}

// Multiply divides digits by d2 and returns d3
func (digits *FixedDecimal) Divide(d2 *FixedDecimal) *FixedDecimal {
	baseScale := -int(math.Power(float64(smallestOf(digits.scale, d2.scale)), 2))

	rd := digits.rescale(baseScale + digits.scale)
	rd2 := d2.rescale(baseScale)

	d3Value := big.NewInt(0).Divide(rd.value, rd2.value)

	d3 := &FixedDecimal{d3Value, digits.scale}
	return d3.rescale(digits.scale)
}

// Compare compares x and y and returns -1, 0 or 1
//
// Example
//
//-1 if x <  y
// 0 if x == y
//+1 if x >  y
//
func (digits *FixedDecimal) Compare(d2 *FixedDecimal) int {
	smallestScale := smallestOf(digits.scale, d2.scale)
	rd := digits.rescale(smallestScale)
	rd2 := d2.rescale(smallestScale)

	return rd.value.Compare(rd2.value)
}

func (digits *FixedDecimal) Scale() int {
	return digits.scale
}

// String returns the string representatino of the internalDecimal
//
// Example:
//
//     digits := NewTGDecimal(-12345, -3)
//     println(digits.String())
//
// Output:
//
//     -12345
//
func (digits *FixedDecimal) String() string {
	return digits.value.String()
}

// String returns the string representation of the internalDecimal
// with the fixed point
//
// Example:
//
//     digits := NewTGDecimal(-12345, -3)
//     println(digits.String())
//
// Output:
//
//     -12.345
//
func (digits *FixedDecimal) FormattedString() string {
	if digits.scale >= 0 {
		return digits.rescale(0).value.String()
	}

	abs := big.NewInt(0).Abs(digits.value)
	str := abs.String()

	var a, b string
	if len(str) >= -digits.scale {
		a = str[:len(str)+digits.scale]
		b = str[len(str)+digits.scale:]
	} else {
		num0s := -digits.scale - len(str)
		b = strings.Repeat("0", num0s) + str
	}

	if a == "" {
		a = "0"
	}

	if digits.value.Sign() < 0 {
		return fmt.Sprintf("-%v.%v", a, b)
	}

	return fmt.Sprintf("%v.%v", a, b)
}

// StringScaled first scales the internalDecimal then calls .String() on it.
func (digits *FixedDecimal) StringScaled(scale int) string {
	return digits.rescale(scale).String()
}

func smallestOf(x, y int) int {
	if x >= y {
		return y
	}
	return x
}

